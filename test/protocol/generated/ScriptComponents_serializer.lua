-- automatically generated by the FlatBuffers compiler, do not modify

local flatbuffers = require('flatbuffers')

local ____exports = {}

local fixed32 = math.fixed32
local value32 = math.value32

local fixed64 = math.fixed64
local value64 = math.value64

-- namespace: Protocol

____exports.MarkedData = {}
local MarkedData = ____exports.MarkedData -- the module
local MarkedData_mt = {} -- the class metatable

function MarkedData.New()
    local o = {}
    setmetatable(o, {__index = MarkedData_mt})
    return o
end
function MarkedData.GetRootAsMarkedData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = MarkedData.New()
    o:Init(buf, n + offset)
    return o
end
function MarkedData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
-- /// 被哪个球员盯防
function MarkedData_mt:MarkedByAthleteEntity()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
-- /// 过人动作起始朝向
function MarkedData_mt:SkillMoveStartDirection()
    local o = self.view:Offset(6)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 前一个预测位置
function MarkedData_mt:PrevExpectedPosition()
    local o = self.view:Offset(8)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 后一个预测位置
function MarkedData_mt:NextExpectedPosition()
    local o = self.view:Offset(10)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 当前预测位置（根据前后预测位置计算）
function MarkedData_mt:ExpectedPosition()
    local o = self.view:Offset(12)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 后一个预测位置的预测时间
function MarkedData_mt:ExpectedTotalRemainingTime()
    local o = self.view:Offset(14)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
-- /// 后一个预测位置所处的动作阶段
function MarkedData_mt:AnimationPhase()
    local o = self.view:Offset(16)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
function MarkedData.Start(builder) builder:StartObject(7) end
function MarkedData.AddMarkedByAthleteEntity(builder, markedByAthleteEntity) builder:PrependInt32Slot(0, markedByAthleteEntity, -1) end
function MarkedData.AddSkillMoveStartDirection(builder, skillMoveStartDirection) builder:PrependStructSlot(1, skillMoveStartDirection, 0) end
function MarkedData.AddPrevExpectedPosition(builder, prevExpectedPosition) builder:PrependStructSlot(2, prevExpectedPosition, 0) end
function MarkedData.AddNextExpectedPosition(builder, nextExpectedPosition) builder:PrependStructSlot(3, nextExpectedPosition, 0) end
function MarkedData.AddExpectedPosition(builder, expectedPosition) builder:PrependStructSlot(4, expectedPosition, 0) end
function MarkedData.AddExpectedTotalRemainingTime(builder, expectedTotalRemainingTime) builder:PrependInt64Slot(5, value64(expectedTotalRemainingTime), (0 --[[ 0 ]])) end
function MarkedData.AddAnimationPhase(builder, animationPhase) builder:PrependInt32Slot(6, animationPhase, -1) end
function MarkedData.End(builder) return builder:EndObject() end

function MarkedData.Pack(builder, _o)
    local _markedByAthleteEntity = _o.markedByAthleteEntity
    local _expectedTotalRemainingTime = _o.expectedTotalRemainingTime
    local _animationPhase = _o.animationPhase

    MarkedData.Start(builder)
    MarkedData.AddAnimationPhase(builder, _animationPhase)
    MarkedData.AddExpectedTotalRemainingTime(builder, _expectedTotalRemainingTime)
    local _expectedPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.expectedPosition)
    MarkedData.AddExpectedPosition(builder, _expectedPosition)
    local _nextExpectedPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.nextExpectedPosition)
    MarkedData.AddNextExpectedPosition(builder, _nextExpectedPosition)
    local _prevExpectedPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.prevExpectedPosition)
    MarkedData.AddPrevExpectedPosition(builder, _prevExpectedPosition)
    local _skillMoveStartDirection = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.skillMoveStartDirection)
    MarkedData.AddSkillMoveStartDirection(builder, _skillMoveStartDirection)
    MarkedData.AddMarkedByAthleteEntity(builder, _markedByAthleteEntity)
    return MarkedData.End(builder)
end

function MarkedData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").MarkedDataT)
    self:UnPackTo(_o)
    return _o
end

function MarkedData_mt:UnPackTo(_o)
    _o.markedByAthleteEntity = self:MarkedByAthleteEntity()
    local _skillMoveStartDirection = self:SkillMoveStartDirection()
    _o.skillMoveStartDirection = _skillMoveStartDirection:UnPack()
    local _prevExpectedPosition = self:PrevExpectedPosition()
    _o.prevExpectedPosition = _prevExpectedPosition:UnPack()
    local _nextExpectedPosition = self:NextExpectedPosition()
    _o.nextExpectedPosition = _nextExpectedPosition:UnPack()
    local _expectedPosition = self:ExpectedPosition()
    _o.expectedPosition = _expectedPosition:UnPack()
    _o.expectedTotalRemainingTime = self:ExpectedTotalRemainingTime()
    _o.animationPhase = self:AnimationPhase()
    return _o
end


____exports.MarkData = {}
local MarkData = ____exports.MarkData -- the module
local MarkData_mt = {} -- the class metatable

function MarkData.New()
    local o = {}
    setmetatable(o, {__index = MarkData_mt})
    return o
end
function MarkData.GetRootAsMarkData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = MarkData.New()
    o:Init(buf, n + offset)
    return o
end
function MarkData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
-- /// 盯防哪个球员
function MarkData_mt:TargetAthleteEntity()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
-- /// 盯防的目标点
function MarkData_mt:TargetPosition()
    local o = self.view:Offset(6)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 盯防策略
function MarkData_mt:Strategy()
    local o = self.view:Offset(8)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
-- /// 是否不做决策
function MarkData_mt:IsNotToMakeDecision()
    local o = self.view:Offset(10)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function MarkData.Start(builder) builder:StartObject(4) end
function MarkData.AddTargetAthleteEntity(builder, targetAthleteEntity) builder:PrependInt32Slot(0, targetAthleteEntity, -1) end
function MarkData.AddTargetPosition(builder, targetPosition) builder:PrependStructSlot(1, targetPosition, 0) end
function MarkData.AddStrategy(builder, strategy) builder:PrependInt16Slot(2, strategy, 0) end
function MarkData.AddIsNotToMakeDecision(builder, isNotToMakeDecision) builder:PrependBoolSlot(3, isNotToMakeDecision, 0) end
function MarkData.End(builder) return builder:EndObject() end

function MarkData.Pack(builder, _o)
    local _targetAthleteEntity = _o.targetAthleteEntity
    local _strategy = _o.strategy
    local _isNotToMakeDecision = _o.isNotToMakeDecision

    MarkData.Start(builder)
    MarkData.AddIsNotToMakeDecision(builder, _isNotToMakeDecision)
    MarkData.AddStrategy(builder, _strategy)
    local _targetPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.targetPosition)
    MarkData.AddTargetPosition(builder, _targetPosition)
    MarkData.AddTargetAthleteEntity(builder, _targetAthleteEntity)
    return MarkData.End(builder)
end

function MarkData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").MarkDataT)
    self:UnPackTo(_o)
    return _o
end

function MarkData_mt:UnPackTo(_o)
    _o.targetAthleteEntity = self:TargetAthleteEntity()
    local _targetPosition = self:TargetPosition()
    _o.targetPosition = _targetPosition:UnPack()
    _o.strategy = self:Strategy()
    _o.isNotToMakeDecision = self:IsNotToMakeDecision()
    return _o
end


____exports.CatchData = {}
local CatchData = ____exports.CatchData -- the module
local CatchData_mt = {} -- the class metatable

function CatchData.New()
    local o = {}
    setmetatable(o, {__index = CatchData_mt})
    return o
end
function CatchData.GetRootAsCatchData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = CatchData.New()
    o:Init(buf, n + offset)
    return o
end
function CatchData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
-- /// 接球移动目标点
function CatchData_mt:MoveTargetPosition()
    local o = self.view:Offset(4)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector3Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 接球移动目标时间
function CatchData_mt:MoveTargetTime()
    local o = self.view:Offset(6)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
-- /// 接球移动目标朝向
function CatchData_mt:MoveTargetDirection()
    local o = self.view:Offset(8)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
-- /// 移动优先级
function CatchData_mt:CatchMovePriority()
    local o = self.view:Offset(10)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
-- /// 是否已选好接球动作
function CatchData_mt:IsCatchAnimationChosen()
    local o = self.view:Offset(12)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function CatchData.Start(builder) builder:StartObject(5) end
function CatchData.AddMoveTargetPosition(builder, moveTargetPosition) builder:PrependStructSlot(0, moveTargetPosition, 0) end
function CatchData.AddMoveTargetTime(builder, moveTargetTime) builder:PrependInt64Slot(1, value64(moveTargetTime), (0 --[[ 0 ]])) end
function CatchData.AddMoveTargetDirection(builder, moveTargetDirection) builder:PrependInt64Slot(2, value64(moveTargetDirection), (0 --[[ 0 ]])) end
function CatchData.AddCatchMovePriority(builder, catchMovePriority) builder:PrependInt16Slot(3, catchMovePriority, 0) end
function CatchData.AddIsCatchAnimationChosen(builder, isCatchAnimationChosen) builder:PrependBoolSlot(4, isCatchAnimationChosen, 0) end
function CatchData.End(builder) return builder:EndObject() end

function CatchData.Pack(builder, _o)
    local _moveTargetTime = _o.moveTargetTime
    local _moveTargetDirection = _o.moveTargetDirection
    local _catchMovePriority = _o.catchMovePriority
    local _isCatchAnimationChosen = _o.isCatchAnimationChosen

    CatchData.Start(builder)
    CatchData.AddIsCatchAnimationChosen(builder, _isCatchAnimationChosen)
    CatchData.AddCatchMovePriority(builder, _catchMovePriority)
    CatchData.AddMoveTargetDirection(builder, _moveTargetDirection)
    CatchData.AddMoveTargetTime(builder, _moveTargetTime)
    local _moveTargetPosition = require("protocol.generated.Native_serializer").Vector3Fix64.Pack(builder, _o.moveTargetPosition)
    CatchData.AddMoveTargetPosition(builder, _moveTargetPosition)
    return CatchData.End(builder)
end

function CatchData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").CatchDataT)
    self:UnPackTo(_o)
    return _o
end

function CatchData_mt:UnPackTo(_o)
    local _moveTargetPosition = self:MoveTargetPosition()
    _o.moveTargetPosition = _moveTargetPosition:UnPack()
    _o.moveTargetTime = self:MoveTargetTime()
    _o.moveTargetDirection = self:MoveTargetDirection()
    _o.catchMovePriority = self:CatchMovePriority()
    _o.isCatchAnimationChosen = self:IsCatchAnimationChosen()
    return _o
end


____exports.HeroMomentData = {}
local HeroMomentData = ____exports.HeroMomentData -- the module
local HeroMomentData_mt = {} -- the class metatable

function HeroMomentData.New()
    local o = {}
    setmetatable(o, {__index = HeroMomentData_mt})
    return o
end
function HeroMomentData.GetRootAsHeroMomentData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = HeroMomentData.New()
    o:Init(buf, n + offset)
    return o
end
function HeroMomentData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
function HeroMomentData_mt:EnterTime()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function HeroMomentData_mt:ExitTime()
    local o = self.view:Offset(6)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function HeroMomentData_mt:AthleteEntity()
    local o = self.view:Offset(8)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
function HeroMomentData.Start(builder) builder:StartObject(3) end
function HeroMomentData.AddEnterTime(builder, enterTime) builder:PrependInt64Slot(0, value64(enterTime), (0 --[[ 0 ]])) end
function HeroMomentData.AddExitTime(builder, exitTime) builder:PrependInt64Slot(1, value64(exitTime), (0 --[[ 0 ]])) end
function HeroMomentData.AddAthleteEntity(builder, athleteEntity) builder:PrependInt32Slot(2, athleteEntity, -1) end
function HeroMomentData.End(builder) return builder:EndObject() end

function HeroMomentData.Pack(builder, _o)
    local _enterTime = _o.enterTime
    local _exitTime = _o.exitTime
    local _athleteEntity = _o.athleteEntity

    HeroMomentData.Start(builder)
    HeroMomentData.AddAthleteEntity(builder, _athleteEntity)
    HeroMomentData.AddExitTime(builder, _exitTime)
    HeroMomentData.AddEnterTime(builder, _enterTime)
    return HeroMomentData.End(builder)
end

function HeroMomentData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").HeroMomentDataT)
    self:UnPackTo(_o)
    return _o
end

function HeroMomentData_mt:UnPackTo(_o)
    _o.enterTime = self:EnterTime()
    _o.exitTime = self:ExitTime()
    _o.athleteEntity = self:AthleteEntity()
    return _o
end


____exports.AthleteData = {}
local AthleteData = ____exports.AthleteData -- the module
local AthleteData_mt = {} -- the class metatable

function AthleteData.New()
    local o = {}
    setmetatable(o, {__index = AthleteData_mt})
    return o
end
function AthleteData.GetRootAsAthleteData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = AthleteData.New()
    o:Init(buf, n + offset)
    return o
end
function AthleteData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
function AthleteData_mt:Position()
    local o = self.view:Offset(4)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:BodyDirection()
    local o = self.view:Offset(6)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:Velocity()
    local o = self.view:Offset(8)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:AverageVelocity()
    local o = self.view:Offset(10)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:RotationVelocity()
    local o = self.view:Offset(12)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function AthleteData_mt:AverageRotationVelocity()
    local o = self.view:Offset(14)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function AthleteData_mt:Acceleration()
    local o = self.view:Offset(16)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function AthleteData_mt:AverageAcceleration()
    local o = self.view:Offset(18)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function AthleteData_mt:Entity()
    local o = self.view:Offset(20)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function AthleteData_mt:TeamEntity()
    local o = self.view:Offset(22)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function AthleteData_mt:MaxSpeed()
    local o = self.view:Offset(24)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 10
end
function AthleteData_mt:HasBall()
    local o = self.view:Offset(26)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function AthleteData_mt:LastHasBall()
    local o = self.view:Offset(28)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function AthleteData_mt:PredictedPosition()
    local o = self.view:Offset(30)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:TargetPositionX()
    local o = self.view:Offset(32)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function AthleteData_mt:TargetPositionY()
    local o = self.view:Offset(34)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function AthleteData_mt:Index()
    local o = self.view:Offset(36)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function AthleteData_mt:CharacterId()
    local o = self.view:Offset(38)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function AthleteData_mt:RoleId()
    local o = self.view:Offset(40)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function AthleteData_mt:Tactics()
    local o = self.view:Offset(42)
    if o ~= 0 then
        local x = self.view:Indirect(o + self.view.pos)
        local obj = ____exports.TacticsConfig.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:IsAtDefenseTargetPosition()
    local o = self.view:Offset(44)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function AthleteData_mt:BehaviorTreeDump()
    local o = self.view:Offset(46)
    if o ~= 0 then
        return self.view:String(o + self.view.pos)
    end
end
function AthleteData_mt:DefenseMentality()
    local o = self.view:Offset(48)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function AthleteData_mt:DefenseStandLine()
    local o = self.view:Offset(50)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function AthleteData_mt:Marked()
    local o = self.view:Offset(52)
    if o ~= 0 then
        local x = self.view:Indirect(o + self.view.pos)
        local obj = ____exports.MarkedData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:Mark()
    local o = self.view:Offset(54)
    if o ~= 0 then
        local x = self.view:Indirect(o + self.view.pos)
        local obj = ____exports.MarkData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 是否需要应用玩家输入
function AthleteData_mt:NeedApplyUserInput()
    local o = self.view:Offset(56)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
-- /// 惯用脚
function AthleteData_mt:PreferredFoot()
    local o = self.view:Offset(58)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 1
end
-- /// 是否在离球帧之前
function AthleteData_mt:IsBeforeDetach()
    local o = self.view:Offset(60)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function AthleteData_mt:CurrentScenarioData()
    local o = self.view:Offset(62)
    if o ~= 0 then
        local x = self.view:Indirect(o + self.view.pos)
        local obj = ____exports.ScenarioData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData_mt:TackleType()
    local o = self.view:Offset(64)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
-- /// 抢断的目标人（可能处于非持球状态）
function AthleteData_mt:TackleTargetAthleteEntity()
    local o = self.view:Offset(66)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
-- /// 抢断者记录的持球人如何对抗抢断
function AthleteData_mt:TackleTargetConfrontDecision()
    local o = self.view:Offset(68)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function AthleteData_mt:Catch()
    local o = self.view:Offset(70)
    if o ~= 0 then
        local x = self.view:Indirect(o + self.view.pos)
        local obj = ____exports.CatchData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function AthleteData.Start(builder) builder:StartObject(34) end
function AthleteData.AddPosition(builder, position) builder:PrependStructSlot(0, position, 0) end
function AthleteData.AddBodyDirection(builder, bodyDirection) builder:PrependStructSlot(1, bodyDirection, 0) end
function AthleteData.AddVelocity(builder, velocity) builder:PrependStructSlot(2, velocity, 0) end
function AthleteData.AddAverageVelocity(builder, averageVelocity) builder:PrependStructSlot(3, averageVelocity, 0) end
function AthleteData.AddRotationVelocity(builder, rotationVelocity) builder:PrependInt64Slot(4, value64(rotationVelocity), (0 --[[ 0 ]])) end
function AthleteData.AddAverageRotationVelocity(builder, averageRotationVelocity) builder:PrependInt64Slot(5, value64(averageRotationVelocity), (0 --[[ 0 ]])) end
function AthleteData.AddAcceleration(builder, acceleration) builder:PrependInt64Slot(6, value64(acceleration), (0 --[[ 0 ]])) end
function AthleteData.AddAverageAcceleration(builder, averageAcceleration) builder:PrependInt64Slot(7, value64(averageAcceleration), (0 --[[ 0 ]])) end
function AthleteData.AddEntity(builder, entity) builder:PrependInt32Slot(8, entity, 0) end
function AthleteData.AddTeamEntity(builder, teamEntity) builder:PrependInt32Slot(9, teamEntity, 0) end
function AthleteData.AddMaxSpeed(builder, maxSpeed) builder:PrependInt64Slot(10, value64(maxSpeed), (42949672960 --[[ 10 ]])) end
function AthleteData.AddHasBall(builder, hasBall) builder:PrependBoolSlot(11, hasBall, 0) end
function AthleteData.AddLastHasBall(builder, lastHasBall) builder:PrependBoolSlot(12, lastHasBall, 0) end
function AthleteData.AddPredictedPosition(builder, predictedPosition) builder:PrependStructSlot(13, predictedPosition, 0) end
function AthleteData.AddTargetPositionX(builder, targetPositionX) builder:PrependInt64Slot(14, value64(targetPositionX), (0 --[[ 0 ]])) end
function AthleteData.AddTargetPositionY(builder, targetPositionY) builder:PrependInt64Slot(15, value64(targetPositionY), (0 --[[ 0 ]])) end
function AthleteData.AddIndex(builder, index) builder:PrependInt32Slot(16, index, 0) end
function AthleteData.AddCharacterId(builder, characterId) builder:PrependInt16Slot(17, characterId, 0) end
function AthleteData.AddRoleId(builder, roleId) builder:PrependInt16Slot(18, roleId, 0) end
function AthleteData.AddTactics(builder, tactics) builder:PrependUOffsetTRelativeSlot(19, tactics, 0) end
function AthleteData.AddIsAtDefenseTargetPosition(builder, isAtDefenseTargetPosition) builder:PrependBoolSlot(20, isAtDefenseTargetPosition, 0) end
function AthleteData.AddBehaviorTreeDump(builder, behaviorTreeDump) builder:PrependUOffsetTRelativeSlot(21, behaviorTreeDump, 0) end
function AthleteData.AddDefenseMentality(builder, defenseMentality) builder:PrependInt16Slot(22, defenseMentality, 0) end
function AthleteData.AddDefenseStandLine(builder, defenseStandLine) builder:PrependInt64Slot(23, value64(defenseStandLine), (0 --[[ 0 ]])) end
function AthleteData.AddMarked(builder, marked) builder:PrependUOffsetTRelativeSlot(24, marked, 0) end
function AthleteData.AddMark(builder, mark) builder:PrependUOffsetTRelativeSlot(25, mark, 0) end
function AthleteData.AddNeedApplyUserInput(builder, needApplyUserInput) builder:PrependBoolSlot(26, needApplyUserInput, 0) end
function AthleteData.AddPreferredFoot(builder, preferredFoot) builder:PrependInt16Slot(27, preferredFoot, 1) end
function AthleteData.AddIsBeforeDetach(builder, isBeforeDetach) builder:PrependBoolSlot(28, isBeforeDetach, 0) end
function AthleteData.AddCurrentScenarioData(builder, currentScenarioData) builder:PrependUOffsetTRelativeSlot(29, currentScenarioData, 0) end
function AthleteData.AddTackleType(builder, tackleType) builder:PrependInt16Slot(30, tackleType, 0) end
function AthleteData.AddTackleTargetAthleteEntity(builder, tackleTargetAthleteEntity) builder:PrependInt32Slot(31, tackleTargetAthleteEntity, -1) end
function AthleteData.AddTackleTargetConfrontDecision(builder, tackleTargetConfrontDecision) builder:PrependInt16Slot(32, tackleTargetConfrontDecision, 0) end
function AthleteData.AddCatch(builder, catch) builder:PrependUOffsetTRelativeSlot(33, catch, 0) end
function AthleteData.End(builder) return builder:EndObject() end

function AthleteData.Pack(builder, _o)
    local _rotationVelocity = _o.rotationVelocity
    local _averageRotationVelocity = _o.averageRotationVelocity
    local _acceleration = _o.acceleration
    local _averageAcceleration = _o.averageAcceleration
    local _entity = _o.entity
    local _teamEntity = _o.teamEntity
    local _maxSpeed = _o.maxSpeed
    local _hasBall = _o.hasBall
    local _lastHasBall = _o.lastHasBall
    local _targetPositionX = _o.targetPositionX
    local _targetPositionY = _o.targetPositionY
    local _index = _o.index
    local _characterId = _o.characterId
    local _roleId = _o.roleId
    local _tactics = _o.tactics and ____exports.TacticsConfig.Pack(builder, _o.tactics) or 0
    local _isAtDefenseTargetPosition = _o.isAtDefenseTargetPosition
    local _behaviorTreeDump = string.len(_o.behaviorTreeDump) > 0 and builder:CreateString(_o.behaviorTreeDump) or 0
    local _defenseMentality = _o.defenseMentality
    local _defenseStandLine = _o.defenseStandLine
    local _marked = _o.marked and ____exports.MarkedData.Pack(builder, _o.marked) or 0
    local _mark = _o.mark and ____exports.MarkData.Pack(builder, _o.mark) or 0
    local _needApplyUserInput = _o.needApplyUserInput
    local _preferredFoot = _o.preferredFoot
    local _isBeforeDetach = _o.isBeforeDetach
    local _currentScenarioData = _o.currentScenarioData and ____exports.ScenarioData.Pack(builder, _o.currentScenarioData) or 0
    local _tackleType = _o.tackleType
    local _tackleTargetAthleteEntity = _o.tackleTargetAthleteEntity
    local _tackleTargetConfrontDecision = _o.tackleTargetConfrontDecision
    local _catch = _o.catch and ____exports.CatchData.Pack(builder, _o.catch) or 0

    AthleteData.Start(builder)
    AthleteData.AddCatch(builder, _catch)
    AthleteData.AddTackleTargetConfrontDecision(builder, _tackleTargetConfrontDecision)
    AthleteData.AddTackleTargetAthleteEntity(builder, _tackleTargetAthleteEntity)
    AthleteData.AddTackleType(builder, _tackleType)
    AthleteData.AddCurrentScenarioData(builder, _currentScenarioData)
    AthleteData.AddIsBeforeDetach(builder, _isBeforeDetach)
    AthleteData.AddPreferredFoot(builder, _preferredFoot)
    AthleteData.AddNeedApplyUserInput(builder, _needApplyUserInput)
    AthleteData.AddMark(builder, _mark)
    AthleteData.AddMarked(builder, _marked)
    AthleteData.AddDefenseStandLine(builder, _defenseStandLine)
    AthleteData.AddDefenseMentality(builder, _defenseMentality)
    AthleteData.AddBehaviorTreeDump(builder, _behaviorTreeDump)
    AthleteData.AddIsAtDefenseTargetPosition(builder, _isAtDefenseTargetPosition)
    AthleteData.AddTactics(builder, _tactics)
    AthleteData.AddRoleId(builder, _roleId)
    AthleteData.AddCharacterId(builder, _characterId)
    AthleteData.AddIndex(builder, _index)
    AthleteData.AddTargetPositionY(builder, _targetPositionY)
    AthleteData.AddTargetPositionX(builder, _targetPositionX)
    local _predictedPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.predictedPosition)
    AthleteData.AddPredictedPosition(builder, _predictedPosition)
    AthleteData.AddLastHasBall(builder, _lastHasBall)
    AthleteData.AddHasBall(builder, _hasBall)
    AthleteData.AddMaxSpeed(builder, _maxSpeed)
    AthleteData.AddTeamEntity(builder, _teamEntity)
    AthleteData.AddEntity(builder, _entity)
    AthleteData.AddAverageAcceleration(builder, _averageAcceleration)
    AthleteData.AddAcceleration(builder, _acceleration)
    AthleteData.AddAverageRotationVelocity(builder, _averageRotationVelocity)
    AthleteData.AddRotationVelocity(builder, _rotationVelocity)
    local _averageVelocity = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.averageVelocity)
    AthleteData.AddAverageVelocity(builder, _averageVelocity)
    local _velocity = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.velocity)
    AthleteData.AddVelocity(builder, _velocity)
    local _bodyDirection = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.bodyDirection)
    AthleteData.AddBodyDirection(builder, _bodyDirection)
    local _position = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.position)
    AthleteData.AddPosition(builder, _position)
    return AthleteData.End(builder)
end

function AthleteData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").AthleteDataT)
    self:UnPackTo(_o)
    return _o
end

function AthleteData_mt:UnPackTo(_o)
    local _position = self:Position()
    _o.position = _position:UnPack()
    local _bodyDirection = self:BodyDirection()
    _o.bodyDirection = _bodyDirection:UnPack()
    local _velocity = self:Velocity()
    _o.velocity = _velocity:UnPack()
    local _averageVelocity = self:AverageVelocity()
    _o.averageVelocity = _averageVelocity:UnPack()
    _o.rotationVelocity = self:RotationVelocity()
    _o.averageRotationVelocity = self:AverageRotationVelocity()
    _o.acceleration = self:Acceleration()
    _o.averageAcceleration = self:AverageAcceleration()
    _o.entity = self:Entity()
    _o.teamEntity = self:TeamEntity()
    _o.maxSpeed = self:MaxSpeed()
    _o.hasBall = self:HasBall()
    _o.lastHasBall = self:LastHasBall()
    local _predictedPosition = self:PredictedPosition()
    _o.predictedPosition = _predictedPosition:UnPack()
    _o.targetPositionX = self:TargetPositionX()
    _o.targetPositionY = self:TargetPositionY()
    _o.index = self:Index()
    _o.characterId = self:CharacterId()
    _o.roleId = self:RoleId()
    local _tactics = self:Tactics()
    if _tactics then
        _o.tactics = _tactics:UnPack()
    else
        _o.tactics = nil
    end
    _o.isAtDefenseTargetPosition = self:IsAtDefenseTargetPosition()
    _o.behaviorTreeDump = self:BehaviorTreeDump()
    _o.defenseMentality = self:DefenseMentality()
    _o.defenseStandLine = self:DefenseStandLine()
    local _marked = self:Marked()
    if _marked then
        _o.marked = _marked:UnPack()
    else
        _o.marked = nil
    end
    local _mark = self:Mark()
    if _mark then
        _o.mark = _mark:UnPack()
    else
        _o.mark = nil
    end
    _o.needApplyUserInput = self:NeedApplyUserInput()
    _o.preferredFoot = self:PreferredFoot()
    _o.isBeforeDetach = self:IsBeforeDetach()
    local _currentScenarioData = self:CurrentScenarioData()
    if _currentScenarioData then
        _o.currentScenarioData = _currentScenarioData:UnPack()
    else
        _o.currentScenarioData = nil
    end
    _o.tackleType = self:TackleType()
    _o.tackleTargetAthleteEntity = self:TackleTargetAthleteEntity()
    _o.tackleTargetConfrontDecision = self:TackleTargetConfrontDecision()
    local _catch = self:Catch()
    if _catch then
        _o.catch = _catch:UnPack()
    else
        _o.catch = nil
    end
    return _o
end


____exports.TeamData = {}
local TeamData = ____exports.TeamData -- the module
local TeamData_mt = {} -- the class metatable

function TeamData.New()
    local o = {}
    setmetatable(o, {__index = TeamData_mt})
    return o
end
function TeamData.GetRootAsTeamData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = TeamData.New()
    o:Init(buf, n + offset)
    return o
end
function TeamData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
function TeamData_mt:Entity()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:FormationId()
    local o = self.view:Offset(6)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:DefenseLinePosition()
    local o = self.view:Offset(8)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:DefenseStrategy()
    local o = self.view:Offset(10)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:AttackMentality()
    local o = self.view:Offset(12)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:AthleteEntities(j)
    local o = self.view:Offset(14)
    if o ~= 0 then
        local a = self.view:Vector(o)
        return self.view:Get(flatbuffers.N.Int32, a + ((j-1) * 4))
    end
    return 0
end
function TeamData_mt:AthleteEntitiesLength()
    local o = self.view:Offset(14)
    if o ~= 0 then
        return self.view:VectorLen(o)
    end
    return 0
end
function TeamData_mt:Role()
    local o = self.view:Offset(16)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:Field()
    local o = self.view:Offset(18)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return -1
end
function TeamData_mt:Side()
    local o = self.view:Offset(20)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:Score()
    local o = self.view:Offset(22)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function TeamData_mt:OtherTeamEntity()
    local o = self.view:Offset(24)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
-- /// 盯防目标球员
function TeamData_mt:MarkAthleteEntity()
    local o = self.view:Offset(26)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
-- /// 是否处于争球模式
function TeamData_mt:IsInBallRivalry()
    local o = self.view:Offset(28)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function TeamData_mt:HeroMoment()
    local o = self.view:Offset(30)
    if o ~= 0 then
        local x = self.view:Indirect(o + self.view.pos)
        local obj = ____exports.HeroMomentData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function TeamData.Start(builder) builder:StartObject(14) end
function TeamData.AddEntity(builder, entity) builder:PrependInt32Slot(0, entity, 0) end
function TeamData.AddFormationId(builder, formationId) builder:PrependInt32Slot(1, formationId, 0) end
function TeamData.AddDefenseLinePosition(builder, defenseLinePosition) builder:PrependInt16Slot(2, defenseLinePosition, 0) end
function TeamData.AddDefenseStrategy(builder, defenseStrategy) builder:PrependInt16Slot(3, defenseStrategy, 0) end
function TeamData.AddAttackMentality(builder, attackMentality) builder:PrependInt16Slot(4, attackMentality, 0) end
function TeamData.AddAthleteEntities(builder, athleteEntities) builder:PrependUOffsetTRelativeSlot(5, athleteEntities, 0) end
function TeamData.StartAthleteEntitiesVector(builder, numElems) return builder:StartVector(4, numElems, 4) end
function TeamData.AddRole(builder, role) builder:PrependInt16Slot(6, role, 0) end
function TeamData.AddField(builder, field) builder:PrependInt16Slot(7, field, -1) end
function TeamData.AddSide(builder, side) builder:PrependInt16Slot(8, side, 0) end
function TeamData.AddScore(builder, score) builder:PrependInt32Slot(9, score, 0) end
function TeamData.AddOtherTeamEntity(builder, otherTeamEntity) builder:PrependInt32Slot(10, otherTeamEntity, -1) end
function TeamData.AddMarkAthleteEntity(builder, markAthleteEntity) builder:PrependInt32Slot(11, markAthleteEntity, -1) end
function TeamData.AddIsInBallRivalry(builder, isInBallRivalry) builder:PrependBoolSlot(12, isInBallRivalry, 0) end
function TeamData.AddHeroMoment(builder, heroMoment) builder:PrependUOffsetTRelativeSlot(13, heroMoment, 0) end
function TeamData.End(builder) return builder:EndObject() end

function TeamData.Pack(builder, _o)
    local _entity = _o.entity
    local _formationId = _o.formationId
    local _defenseLinePosition = _o.defenseLinePosition
    local _defenseStrategy = _o.defenseStrategy
    local _attackMentality = _o.attackMentality
    local _athleteEntities = 0
    local _athleteEntitiesLength = #_o.athleteEntities
    if _athleteEntitiesLength > 0 then
        TeamData.StartAthleteEntitiesVector(builder, _athleteEntitiesLength)
        for i = _athleteEntitiesLength, 1, -1 do
            builder:PrependInt32(_o.athleteEntities[i])
        end
        _athleteEntities = builder:EndVector(_athleteEntitiesLength)
    end
    local _role = _o.role
    local _field = _o.field
    local _side = _o.side
    local _score = _o.score
    local _otherTeamEntity = _o.otherTeamEntity
    local _markAthleteEntity = _o.markAthleteEntity
    local _isInBallRivalry = _o.isInBallRivalry
    local _heroMoment = _o.heroMoment and ____exports.HeroMomentData.Pack(builder, _o.heroMoment) or 0

    TeamData.Start(builder)
    TeamData.AddHeroMoment(builder, _heroMoment)
    TeamData.AddIsInBallRivalry(builder, _isInBallRivalry)
    TeamData.AddMarkAthleteEntity(builder, _markAthleteEntity)
    TeamData.AddOtherTeamEntity(builder, _otherTeamEntity)
    TeamData.AddScore(builder, _score)
    TeamData.AddSide(builder, _side)
    TeamData.AddField(builder, _field)
    TeamData.AddRole(builder, _role)
    TeamData.AddAthleteEntities(builder, _athleteEntities)
    TeamData.AddAttackMentality(builder, _attackMentality)
    TeamData.AddDefenseStrategy(builder, _defenseStrategy)
    TeamData.AddDefenseLinePosition(builder, _defenseLinePosition)
    TeamData.AddFormationId(builder, _formationId)
    TeamData.AddEntity(builder, _entity)
    return TeamData.End(builder)
end

function TeamData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").TeamDataT)
    self:UnPackTo(_o)
    return _o
end

function TeamData_mt:UnPackTo(_o)
    _o.entity = self:Entity()
    _o.formationId = self:FormationId()
    _o.defenseLinePosition = self:DefenseLinePosition()
    _o.defenseStrategy = self:DefenseStrategy()
    _o.attackMentality = self:AttackMentality()
    _o.athleteEntities = {}
    for i = 1, self:AthleteEntitiesLength() do
        _o.athleteEntities[i] = self:AthleteEntities(i)
    end
    _o.role = self:Role()
    _o.field = self:Field()
    _o.side = self:Side()
    _o.score = self:Score()
    _o.otherTeamEntity = self:OtherTeamEntity()
    _o.markAthleteEntity = self:MarkAthleteEntity()
    _o.isInBallRivalry = self:IsInBallRivalry()
    local _heroMoment = self:HeroMoment()
    if _heroMoment then
        _o.heroMoment = _heroMoment:UnPack()
    else
        _o.heroMoment = nil
    end
    return _o
end


____exports.MatchData = {}
local MatchData = ____exports.MatchData -- the module
local MatchData_mt = {} -- the class metatable

function MatchData.New()
    local o = {}
    setmetatable(o, {__index = MatchData_mt})
    return o
end
function MatchData.GetRootAsMatchData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = MatchData.New()
    o:Init(buf, n + offset)
    return o
end
function MatchData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
function MatchData_mt:FormationId()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function MatchData_mt:AttackTeamEntity()
    local o = self.view:Offset(6)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
function MatchData_mt:DefenceTeamEntity()
    local o = self.view:Offset(8)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
function MatchData_mt:WithBallAthleteEntity()
    local o = self.view:Offset(10)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
function MatchData_mt:BallEntity()
    local o = self.view:Offset(12)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return -1
end
function MatchData_mt:MatchEvent()
    local o = self.view:Offset(14)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function MatchData_mt:DeadBallCountdownTime()
    local o = self.view:Offset(16)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function MatchData_mt:YAtkDCLine()
    local o = self.view:Offset(18)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function MatchData_mt:YDefDCLine()
    local o = self.view:Offset(20)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function MatchData_mt:AtkToDefDistance()
    local o = self.view:Offset(22)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function MatchData_mt:YDefFCLine()
    local o = self.view:Offset(24)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function MatchData_mt:YBallAtkLerp()
    local o = self.view:Offset(26)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function MatchData_mt:YBallDefLerp()
    local o = self.view:Offset(28)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
-- /// 是否在比赛进程中
function MatchData_mt:InMatch()
    local o = self.view:Offset(30)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
-- /// 比赛状态，参考MatchState
function MatchData_mt:MatchState()
    local o = self.view:Offset(32)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 1
end
-- /// 比赛阶段，参考MatchStage
function MatchData_mt:MatchStage()
    local o = self.view:Offset(34)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return -1
end
-- /// 比赛时间，从0开始，单位为秒
function MatchData_mt:MatchTime()
    local o = self.view:Offset(36)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
-- /// 比赛时间，不一定从0开始，单位为分钟
function MatchData_mt:MatchMinutes()
    local o = self.view:Offset(38)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
-- /// 是否可以有加时赛
function MatchData_mt:HasExtraTimeStage()
    local o = self.view:Offset(40)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
-- /// 是否可以有点球大战
function MatchData_mt:HasPenaltyShootoutStage()
    local o = self.view:Offset(42)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
-- /// 是否从特定的比赛阶段开始比赛
function MatchData_mt:IsSpecialStart()
    local o = self.view:Offset(44)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
-- /// 伤停补时
function MatchData_mt:StoppageMinutes(j)
    local o = self.view:Offset(46)
    if o ~= 0 then
        local a = self.view:Vector(o)
        return self.view:Get(flatbuffers.N.Int16, a + ((j-1) * 2))
    end
    return 0
end
function MatchData_mt:StoppageMinutesLength()
    local o = self.view:Offset(46)
    if o ~= 0 then
        return self.view:VectorLen(o)
    end
    return 0
end
-- /// 比赛各阶段因罚球点球等而延长结束的时间
function MatchData_mt:StageDeltaMinutes(j)
    local o = self.view:Offset(48)
    if o ~= 0 then
        local a = self.view:Vector(o)
        return self.view:Get(flatbuffers.N.Int16, a + ((j-1) * 2))
    end
    return 0
end
function MatchData_mt:StageDeltaMinutesLength()
    local o = self.view:Offset(48)
    if o ~= 0 then
        return self.view:VectorLen(o)
    end
    return 0
end
function MatchData_mt:BallPosition()
    local o = self.view:Offset(50)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function MatchData_mt:BallVelocity()
    local o = self.view:Offset(52)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
-- /// 球的当前位置往当前方向延申n米
function MatchData_mt:ExpectedBallPosition()
    local o = self.view:Offset(54)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function MatchData.Start(builder) builder:StartObject(26) end
function MatchData.AddFormationId(builder, formationId) builder:PrependInt32Slot(0, formationId, 0) end
function MatchData.AddAttackTeamEntity(builder, attackTeamEntity) builder:PrependInt32Slot(1, attackTeamEntity, -1) end
function MatchData.AddDefenceTeamEntity(builder, defenceTeamEntity) builder:PrependInt32Slot(2, defenceTeamEntity, -1) end
function MatchData.AddWithBallAthleteEntity(builder, withBallAthleteEntity) builder:PrependInt32Slot(3, withBallAthleteEntity, -1) end
function MatchData.AddBallEntity(builder, ballEntity) builder:PrependInt32Slot(4, ballEntity, -1) end
function MatchData.AddMatchEvent(builder, matchEvent) builder:PrependInt16Slot(5, matchEvent, 0) end
function MatchData.AddDeadBallCountdownTime(builder, deadBallCountdownTime) builder:PrependInt64Slot(6, value64(deadBallCountdownTime), (0 --[[ 0 ]])) end
function MatchData.AddYAtkDCLine(builder, yAtkDCLine) builder:PrependInt64Slot(7, value64(yAtkDCLine), (0 --[[ 0 ]])) end
function MatchData.AddYDefDCLine(builder, yDefDCLine) builder:PrependInt64Slot(8, value64(yDefDCLine), (0 --[[ 0 ]])) end
function MatchData.AddAtkToDefDistance(builder, AtkToDefDistance) builder:PrependInt64Slot(9, value64(AtkToDefDistance), (0 --[[ 0 ]])) end
function MatchData.AddYDefFCLine(builder, yDefFCLine) builder:PrependInt64Slot(10, value64(yDefFCLine), (0 --[[ 0 ]])) end
function MatchData.AddYBallAtkLerp(builder, yBallAtkLerp) builder:PrependInt64Slot(11, value64(yBallAtkLerp), (0 --[[ 0 ]])) end
function MatchData.AddYBallDefLerp(builder, yBallDefLerp) builder:PrependInt64Slot(12, value64(yBallDefLerp), (0 --[[ 0 ]])) end
function MatchData.AddInMatch(builder, inMatch) builder:PrependBoolSlot(13, inMatch, 0) end
function MatchData.AddMatchState(builder, matchState) builder:PrependInt16Slot(14, matchState, 1) end
function MatchData.AddMatchStage(builder, matchStage) builder:PrependInt16Slot(15, matchStage, -1) end
function MatchData.AddMatchTime(builder, matchTime) builder:PrependInt64Slot(16, value64(matchTime), (0 --[[ 0 ]])) end
function MatchData.AddMatchMinutes(builder, matchMinutes) builder:PrependInt64Slot(17, value64(matchMinutes), (0 --[[ 0 ]])) end
function MatchData.AddHasExtraTimeStage(builder, hasExtraTimeStage) builder:PrependBoolSlot(18, hasExtraTimeStage, 0) end
function MatchData.AddHasPenaltyShootoutStage(builder, hasPenaltyShootoutStage) builder:PrependBoolSlot(19, hasPenaltyShootoutStage, 0) end
function MatchData.AddIsSpecialStart(builder, isSpecialStart) builder:PrependBoolSlot(20, isSpecialStart, 0) end
function MatchData.AddStoppageMinutes(builder, stoppageMinutes) builder:PrependUOffsetTRelativeSlot(21, stoppageMinutes, 0) end
function MatchData.StartStoppageMinutesVector(builder, numElems) return builder:StartVector(2, numElems, 2) end
function MatchData.AddStageDeltaMinutes(builder, stageDeltaMinutes) builder:PrependUOffsetTRelativeSlot(22, stageDeltaMinutes, 0) end
function MatchData.StartStageDeltaMinutesVector(builder, numElems) return builder:StartVector(2, numElems, 2) end
function MatchData.AddBallPosition(builder, ballPosition) builder:PrependStructSlot(23, ballPosition, 0) end
function MatchData.AddBallVelocity(builder, ballVelocity) builder:PrependStructSlot(24, ballVelocity, 0) end
function MatchData.AddExpectedBallPosition(builder, expectedBallPosition) builder:PrependStructSlot(25, expectedBallPosition, 0) end
function MatchData.End(builder) return builder:EndObject() end

function MatchData.Pack(builder, _o)
    local _formationId = _o.formationId
    local _attackTeamEntity = _o.attackTeamEntity
    local _defenceTeamEntity = _o.defenceTeamEntity
    local _withBallAthleteEntity = _o.withBallAthleteEntity
    local _ballEntity = _o.ballEntity
    local _matchEvent = _o.matchEvent
    local _deadBallCountdownTime = _o.deadBallCountdownTime
    local _yAtkDCLine = _o.yAtkDCLine
    local _yDefDCLine = _o.yDefDCLine
    local _AtkToDefDistance = _o.AtkToDefDistance
    local _yDefFCLine = _o.yDefFCLine
    local _yBallAtkLerp = _o.yBallAtkLerp
    local _yBallDefLerp = _o.yBallDefLerp
    local _inMatch = _o.inMatch
    local _matchState = _o.matchState
    local _matchStage = _o.matchStage
    local _matchTime = _o.matchTime
    local _matchMinutes = _o.matchMinutes
    local _hasExtraTimeStage = _o.hasExtraTimeStage
    local _hasPenaltyShootoutStage = _o.hasPenaltyShootoutStage
    local _isSpecialStart = _o.isSpecialStart
    local _stoppageMinutes = 0
    local _stoppageMinutesLength = #_o.stoppageMinutes
    if _stoppageMinutesLength > 0 then
        MatchData.StartStoppageMinutesVector(builder, _stoppageMinutesLength)
        for i = _stoppageMinutesLength, 1, -1 do
            builder:PrependInt16(_o.stoppageMinutes[i])
        end
        _stoppageMinutes = builder:EndVector(_stoppageMinutesLength)
    end
    local _stageDeltaMinutes = 0
    local _stageDeltaMinutesLength = #_o.stageDeltaMinutes
    if _stageDeltaMinutesLength > 0 then
        MatchData.StartStageDeltaMinutesVector(builder, _stageDeltaMinutesLength)
        for i = _stageDeltaMinutesLength, 1, -1 do
            builder:PrependInt16(_o.stageDeltaMinutes[i])
        end
        _stageDeltaMinutes = builder:EndVector(_stageDeltaMinutesLength)
    end

    MatchData.Start(builder)
    local _expectedBallPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.expectedBallPosition)
    MatchData.AddExpectedBallPosition(builder, _expectedBallPosition)
    local _ballVelocity = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.ballVelocity)
    MatchData.AddBallVelocity(builder, _ballVelocity)
    local _ballPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.ballPosition)
    MatchData.AddBallPosition(builder, _ballPosition)
    MatchData.AddStageDeltaMinutes(builder, _stageDeltaMinutes)
    MatchData.AddStoppageMinutes(builder, _stoppageMinutes)
    MatchData.AddIsSpecialStart(builder, _isSpecialStart)
    MatchData.AddHasPenaltyShootoutStage(builder, _hasPenaltyShootoutStage)
    MatchData.AddHasExtraTimeStage(builder, _hasExtraTimeStage)
    MatchData.AddMatchMinutes(builder, _matchMinutes)
    MatchData.AddMatchTime(builder, _matchTime)
    MatchData.AddMatchStage(builder, _matchStage)
    MatchData.AddMatchState(builder, _matchState)
    MatchData.AddInMatch(builder, _inMatch)
    MatchData.AddYBallDefLerp(builder, _yBallDefLerp)
    MatchData.AddYBallAtkLerp(builder, _yBallAtkLerp)
    MatchData.AddYDefFCLine(builder, _yDefFCLine)
    MatchData.AddAtkToDefDistance(builder, _AtkToDefDistance)
    MatchData.AddYDefDCLine(builder, _yDefDCLine)
    MatchData.AddYAtkDCLine(builder, _yAtkDCLine)
    MatchData.AddDeadBallCountdownTime(builder, _deadBallCountdownTime)
    MatchData.AddMatchEvent(builder, _matchEvent)
    MatchData.AddBallEntity(builder, _ballEntity)
    MatchData.AddWithBallAthleteEntity(builder, _withBallAthleteEntity)
    MatchData.AddDefenceTeamEntity(builder, _defenceTeamEntity)
    MatchData.AddAttackTeamEntity(builder, _attackTeamEntity)
    MatchData.AddFormationId(builder, _formationId)
    return MatchData.End(builder)
end

function MatchData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").MatchDataT)
    self:UnPackTo(_o)
    return _o
end

function MatchData_mt:UnPackTo(_o)
    _o.formationId = self:FormationId()
    _o.attackTeamEntity = self:AttackTeamEntity()
    _o.defenceTeamEntity = self:DefenceTeamEntity()
    _o.withBallAthleteEntity = self:WithBallAthleteEntity()
    _o.ballEntity = self:BallEntity()
    _o.matchEvent = self:MatchEvent()
    _o.deadBallCountdownTime = self:DeadBallCountdownTime()
    _o.yAtkDCLine = self:YAtkDCLine()
    _o.yDefDCLine = self:YDefDCLine()
    _o.AtkToDefDistance = self:AtkToDefDistance()
    _o.yDefFCLine = self:YDefFCLine()
    _o.yBallAtkLerp = self:YBallAtkLerp()
    _o.yBallDefLerp = self:YBallDefLerp()
    _o.inMatch = self:InMatch()
    _o.matchState = self:MatchState()
    _o.matchStage = self:MatchStage()
    _o.matchTime = self:MatchTime()
    _o.matchMinutes = self:MatchMinutes()
    _o.hasExtraTimeStage = self:HasExtraTimeStage()
    _o.hasPenaltyShootoutStage = self:HasPenaltyShootoutStage()
    _o.isSpecialStart = self:IsSpecialStart()
    _o.stoppageMinutes = {}
    for i = 1, self:StoppageMinutesLength() do
        _o.stoppageMinutes[i] = self:StoppageMinutes(i)
    end
    _o.stageDeltaMinutes = {}
    for i = 1, self:StageDeltaMinutesLength() do
        _o.stageDeltaMinutes[i] = self:StageDeltaMinutes(i)
    end
    local _ballPosition = self:BallPosition()
    _o.ballPosition = _ballPosition:UnPack()
    local _ballVelocity = self:BallVelocity()
    _o.ballVelocity = _ballVelocity:UnPack()
    local _expectedBallPosition = self:ExpectedBallPosition()
    _o.expectedBallPosition = _expectedBallPosition:UnPack()
    return _o
end


____exports.TacticsConfig = {}
local TacticsConfig = ____exports.TacticsConfig -- the module
local TacticsConfig_mt = {} -- the class metatable

function TacticsConfig.New()
    local o = {}
    setmetatable(o, {__index = TacticsConfig_mt})
    return o
end
function TacticsConfig.GetRootAsTacticsConfig(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = TacticsConfig.New()
    o:Init(buf, n + offset)
    return o
end
function TacticsConfig_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
function TacticsConfig_mt:XAtkDefault()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:XAtkOffset()
    local o = self.view:Offset(6)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:YAtkShrinkLine()
    local o = self.view:Offset(8)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:XAtkShrinkCoefficient()
    local o = self.view:Offset(10)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:XAtkCompress()
    local o = self.view:Offset(12)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:FormationPercentageAtkMin()
    local o = self.view:Offset(14)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:FormationPercentageAtkMax()
    local o = self.view:Offset(16)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:AtkMoveFurtherUp()
    local o = self.view:Offset(18)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:XDefDefault()
    local o = self.view:Offset(20)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:XDefOffset()
    local o = self.view:Offset(22)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:YDefShrinkLine()
    local o = self.view:Offset(24)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:XDefShrinkCoefficient()
    local o = self.view:Offset(26)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:XDefCompress()
    local o = self.view:Offset(28)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:FormationPercentageDefMin()
    local o = self.view:Offset(30)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:FormationPercentageDefMax()
    local o = self.view:Offset(32)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig_mt:DefMoveFurtherUp()
    local o = self.view:Offset(34)
    if o ~= 0 then
        return fixed64(self.view:Get(flatbuffers.N.Int64, o + self.view.pos))
    end
    return 0
end
function TacticsConfig.Start(builder) builder:StartObject(16) end
function TacticsConfig.AddXAtkDefault(builder, xAtkDefault) builder:PrependInt64Slot(0, value64(xAtkDefault), (0 --[[ 0 ]])) end
function TacticsConfig.AddXAtkOffset(builder, xAtkOffset) builder:PrependInt64Slot(1, value64(xAtkOffset), (0 --[[ 0 ]])) end
function TacticsConfig.AddYAtkShrinkLine(builder, yAtkShrinkLine) builder:PrependInt64Slot(2, value64(yAtkShrinkLine), (0 --[[ 0 ]])) end
function TacticsConfig.AddXAtkShrinkCoefficient(builder, xAtkShrinkCoefficient) builder:PrependInt64Slot(3, value64(xAtkShrinkCoefficient), (0 --[[ 0 ]])) end
function TacticsConfig.AddXAtkCompress(builder, xAtkCompress) builder:PrependInt64Slot(4, value64(xAtkCompress), (0 --[[ 0 ]])) end
function TacticsConfig.AddFormationPercentageAtkMin(builder, formationPercentageAtkMin) builder:PrependInt64Slot(5, value64(formationPercentageAtkMin), (0 --[[ 0 ]])) end
function TacticsConfig.AddFormationPercentageAtkMax(builder, formationPercentageAtkMax) builder:PrependInt64Slot(6, value64(formationPercentageAtkMax), (0 --[[ 0 ]])) end
function TacticsConfig.AddAtkMoveFurtherUp(builder, atkMoveFurtherUp) builder:PrependInt64Slot(7, value64(atkMoveFurtherUp), (0 --[[ 0 ]])) end
function TacticsConfig.AddXDefDefault(builder, xDefDefault) builder:PrependInt64Slot(8, value64(xDefDefault), (0 --[[ 0 ]])) end
function TacticsConfig.AddXDefOffset(builder, xDefOffset) builder:PrependInt64Slot(9, value64(xDefOffset), (0 --[[ 0 ]])) end
function TacticsConfig.AddYDefShrinkLine(builder, yDefShrinkLine) builder:PrependInt64Slot(10, value64(yDefShrinkLine), (0 --[[ 0 ]])) end
function TacticsConfig.AddXDefShrinkCoefficient(builder, xDefShrinkCoefficient) builder:PrependInt64Slot(11, value64(xDefShrinkCoefficient), (0 --[[ 0 ]])) end
function TacticsConfig.AddXDefCompress(builder, xDefCompress) builder:PrependInt64Slot(12, value64(xDefCompress), (0 --[[ 0 ]])) end
function TacticsConfig.AddFormationPercentageDefMin(builder, formationPercentageDefMin) builder:PrependInt64Slot(13, value64(formationPercentageDefMin), (0 --[[ 0 ]])) end
function TacticsConfig.AddFormationPercentageDefMax(builder, formationPercentageDefMax) builder:PrependInt64Slot(14, value64(formationPercentageDefMax), (0 --[[ 0 ]])) end
function TacticsConfig.AddDefMoveFurtherUp(builder, defMoveFurtherUp) builder:PrependInt64Slot(15, value64(defMoveFurtherUp), (0 --[[ 0 ]])) end
function TacticsConfig.End(builder) return builder:EndObject() end

function TacticsConfig.Pack(builder, _o)
    local _xAtkDefault = _o.xAtkDefault
    local _xAtkOffset = _o.xAtkOffset
    local _yAtkShrinkLine = _o.yAtkShrinkLine
    local _xAtkShrinkCoefficient = _o.xAtkShrinkCoefficient
    local _xAtkCompress = _o.xAtkCompress
    local _formationPercentageAtkMin = _o.formationPercentageAtkMin
    local _formationPercentageAtkMax = _o.formationPercentageAtkMax
    local _atkMoveFurtherUp = _o.atkMoveFurtherUp
    local _xDefDefault = _o.xDefDefault
    local _xDefOffset = _o.xDefOffset
    local _yDefShrinkLine = _o.yDefShrinkLine
    local _xDefShrinkCoefficient = _o.xDefShrinkCoefficient
    local _xDefCompress = _o.xDefCompress
    local _formationPercentageDefMin = _o.formationPercentageDefMin
    local _formationPercentageDefMax = _o.formationPercentageDefMax
    local _defMoveFurtherUp = _o.defMoveFurtherUp

    TacticsConfig.Start(builder)
    TacticsConfig.AddDefMoveFurtherUp(builder, _defMoveFurtherUp)
    TacticsConfig.AddFormationPercentageDefMax(builder, _formationPercentageDefMax)
    TacticsConfig.AddFormationPercentageDefMin(builder, _formationPercentageDefMin)
    TacticsConfig.AddXDefCompress(builder, _xDefCompress)
    TacticsConfig.AddXDefShrinkCoefficient(builder, _xDefShrinkCoefficient)
    TacticsConfig.AddYDefShrinkLine(builder, _yDefShrinkLine)
    TacticsConfig.AddXDefOffset(builder, _xDefOffset)
    TacticsConfig.AddXDefDefault(builder, _xDefDefault)
    TacticsConfig.AddAtkMoveFurtherUp(builder, _atkMoveFurtherUp)
    TacticsConfig.AddFormationPercentageAtkMax(builder, _formationPercentageAtkMax)
    TacticsConfig.AddFormationPercentageAtkMin(builder, _formationPercentageAtkMin)
    TacticsConfig.AddXAtkCompress(builder, _xAtkCompress)
    TacticsConfig.AddXAtkShrinkCoefficient(builder, _xAtkShrinkCoefficient)
    TacticsConfig.AddYAtkShrinkLine(builder, _yAtkShrinkLine)
    TacticsConfig.AddXAtkOffset(builder, _xAtkOffset)
    TacticsConfig.AddXAtkDefault(builder, _xAtkDefault)
    return TacticsConfig.End(builder)
end

function TacticsConfig_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").TacticsConfigT)
    self:UnPackTo(_o)
    return _o
end

function TacticsConfig_mt:UnPackTo(_o)
    _o.xAtkDefault = self:XAtkDefault()
    _o.xAtkOffset = self:XAtkOffset()
    _o.yAtkShrinkLine = self:YAtkShrinkLine()
    _o.xAtkShrinkCoefficient = self:XAtkShrinkCoefficient()
    _o.xAtkCompress = self:XAtkCompress()
    _o.formationPercentageAtkMin = self:FormationPercentageAtkMin()
    _o.formationPercentageAtkMax = self:FormationPercentageAtkMax()
    _o.atkMoveFurtherUp = self:AtkMoveFurtherUp()
    _o.xDefDefault = self:XDefDefault()
    _o.xDefOffset = self:XDefOffset()
    _o.yDefShrinkLine = self:YDefShrinkLine()
    _o.xDefShrinkCoefficient = self:XDefShrinkCoefficient()
    _o.xDefCompress = self:XDefCompress()
    _o.formationPercentageDefMin = self:FormationPercentageDefMin()
    _o.formationPercentageDefMax = self:FormationPercentageDefMax()
    _o.defMoveFurtherUp = self:DefMoveFurtherUp()
    return _o
end


____exports.ScriptRecord = {}
local ScriptRecord = ____exports.ScriptRecord -- the module
local ScriptRecord_mt = {} -- the class metatable

function ScriptRecord.New()
    local o = {}
    setmetatable(o, {__index = ScriptRecord_mt})
    return o
end
function ScriptRecord.GetRootAsScriptRecord(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = ScriptRecord.New()
    o:Init(buf, n + offset)
    return o
end
function ScriptRecord_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
function ScriptRecord_mt:AthleteData(j)
    local o = self.view:Offset(4)
    if o ~= 0 then
        local x = self.view:Vector(o)
        x = x + ((j-1) * 4)
        x = self.view:Indirect(x)
        local obj = ____exports.AthleteData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function ScriptRecord_mt:AthleteDataLength()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return self.view:VectorLen(o)
    end
    return 0
end
function ScriptRecord_mt:TeamData(j)
    local o = self.view:Offset(6)
    if o ~= 0 then
        local x = self.view:Vector(o)
        x = x + ((j-1) * 4)
        x = self.view:Indirect(x)
        local obj = ____exports.TeamData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function ScriptRecord_mt:TeamDataLength()
    local o = self.view:Offset(6)
    if o ~= 0 then
        return self.view:VectorLen(o)
    end
    return 0
end
function ScriptRecord_mt:MatchData()
    local o = self.view:Offset(8)
    if o ~= 0 then
        local x = self.view:Indirect(o + self.view.pos)
        local obj = ____exports.MatchData.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function ScriptRecord.Start(builder) builder:StartObject(3) end
function ScriptRecord.AddAthleteData(builder, athleteData) builder:PrependUOffsetTRelativeSlot(0, athleteData, 0) end
function ScriptRecord.StartAthleteDataVector(builder, numElems) return builder:StartVector(4, numElems, 4) end
function ScriptRecord.AddTeamData(builder, teamData) builder:PrependUOffsetTRelativeSlot(1, teamData, 0) end
function ScriptRecord.StartTeamDataVector(builder, numElems) return builder:StartVector(4, numElems, 4) end
function ScriptRecord.AddMatchData(builder, matchData) builder:PrependUOffsetTRelativeSlot(2, matchData, 0) end
function ScriptRecord.End(builder) return builder:EndObject() end

function ScriptRecord.Pack(builder, _o)
    local _athleteData = 0
    local _athleteDataLength = #_o.athleteData
    if _athleteDataLength > 0 then
        local __elems = {}
        for i = 1, _athleteDataLength do
            __elems[i] = ____exports.AthleteData.Pack(builder, _o.athleteData[i])
        end
        ScriptRecord.StartAthleteDataVector(builder, _athleteDataLength)
        for i = _athleteDataLength, 1, -1 do
            builder:PrependUOffsetTRelative(__elems[i])
        end
        _athleteData = builder:EndVector(_athleteDataLength)
    end
    local _teamData = 0
    local _teamDataLength = #_o.teamData
    if _teamDataLength > 0 then
        local __elems = {}
        for i = 1, _teamDataLength do
            __elems[i] = ____exports.TeamData.Pack(builder, _o.teamData[i])
        end
        ScriptRecord.StartTeamDataVector(builder, _teamDataLength)
        for i = _teamDataLength, 1, -1 do
            builder:PrependUOffsetTRelative(__elems[i])
        end
        _teamData = builder:EndVector(_teamDataLength)
    end
    local _matchData = _o.matchData and ____exports.MatchData.Pack(builder, _o.matchData) or 0

    ScriptRecord.Start(builder)
    ScriptRecord.AddMatchData(builder, _matchData)
    ScriptRecord.AddTeamData(builder, _teamData)
    ScriptRecord.AddAthleteData(builder, _athleteData)
    return ScriptRecord.End(builder)
end

function ScriptRecord_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").ScriptRecordT)
    self:UnPackTo(_o)
    return _o
end

function ScriptRecord_mt:UnPackTo(_o)
    _o.athleteData = {}
    for i = 1, self:AthleteDataLength() do
        _o.athleteData[i] = self:AthleteData(i):UnPack()
    end
    _o.teamData = {}
    for i = 1, self:TeamDataLength() do
        _o.teamData[i] = self:TeamData(i):UnPack()
    end
    local _matchData = self:MatchData()
    if _matchData then
        _o.matchData = _matchData:UnPack()
    else
        _o.matchData = nil
    end
    return _o
end


____exports.ScenarioData = {}
local ScenarioData = ____exports.ScenarioData -- the module
local ScenarioData_mt = {} -- the class metatable

function ScenarioData.New()
    local o = {}
    setmetatable(o, {__index = ScenarioData_mt})
    return o
end
function ScenarioData.GetRootAsScenarioData(buf, offset)
    local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)
    local o = ScenarioData.New()
    o:Init(buf, n + offset)
    return o
end
function ScenarioData_mt:Init(buf, pos)
    self.view = flatbuffers.view.New(buf, pos)
end
function ScenarioData_mt:Name()
    local o = self.view:Offset(4)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int16, o + self.view.pos)
    end
    return 0
end
function ScenarioData_mt:Phase()
    local o = self.view:Offset(6)
    if o ~= 0 then
        return self.view:Get(flatbuffers.N.Int32, o + self.view.pos)
    end
    return 0
end
function ScenarioData_mt:EnterPosition()
    local o = self.view:Offset(8)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function ScenarioData_mt:SkillMoveDisplacement()
    local o = self.view:Offset(10)
    if o ~= 0 then
        local x = o + self.view.pos
        local obj = require("protocol.generated.Native_serializer").Vector2Fix64.New()
        obj:Init(self.view.bytes, x)
        return obj
    end
end
function ScenarioData_mt:HasPerformedSkillMove()
    local o = self.view:Offset(12)
    if o ~= 0 then
        return (self.view:Get(flatbuffers.N.Bool, o + self.view.pos) ~= 0)
    end
    return false
end
function ScenarioData.Start(builder) builder:StartObject(5) end
function ScenarioData.AddName(builder, name) builder:PrependInt16Slot(0, name, 0) end
function ScenarioData.AddPhase(builder, phase) builder:PrependInt32Slot(1, phase, 0) end
function ScenarioData.AddEnterPosition(builder, enterPosition) builder:PrependStructSlot(2, enterPosition, 0) end
function ScenarioData.AddSkillMoveDisplacement(builder, skillMoveDisplacement) builder:PrependStructSlot(3, skillMoveDisplacement, 0) end
function ScenarioData.AddHasPerformedSkillMove(builder, hasPerformedSkillMove) builder:PrependBoolSlot(4, hasPerformedSkillMove, 0) end
function ScenarioData.End(builder) return builder:EndObject() end

function ScenarioData.Pack(builder, _o)
    local _name = _o.name
    local _phase = _o.phase
    local _hasPerformedSkillMove = _o.hasPerformedSkillMove

    ScenarioData.Start(builder)
    ScenarioData.AddHasPerformedSkillMove(builder, _hasPerformedSkillMove)
    local _skillMoveDisplacement = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.skillMoveDisplacement)
    ScenarioData.AddSkillMoveDisplacement(builder, _skillMoveDisplacement)
    local _enterPosition = require("protocol.generated.Native_serializer").Vector2Fix64.Pack(builder, _o.enterPosition)
    ScenarioData.AddEnterPosition(builder, _enterPosition)
    ScenarioData.AddPhase(builder, _phase)
    ScenarioData.AddName(builder, _name)
    return ScenarioData.End(builder)
end

function ScenarioData_mt:UnPack()
    local _o = __TS__New(require("protocol.generated.ScriptComponents_generated").ScenarioDataT)
    self:UnPackTo(_o)
    return _o
end

function ScenarioData_mt:UnPackTo(_o)
    _o.name = self:Name()
    _o.phase = self:Phase()
    local _enterPosition = self:EnterPosition()
    _o.enterPosition = _enterPosition:UnPack()
    local _skillMoveDisplacement = self:SkillMoveDisplacement()
    _o.skillMoveDisplacement = _skillMoveDisplacement:UnPack()
    _o.hasPerformedSkillMove = self:HasPerformedSkillMove()
    return _o
end


return ____exports